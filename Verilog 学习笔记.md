## Verilog 学习笔记

**1**

+ wire 的中文可以翻译为导线，但 Verilog 中的 wire 和现实中的导线不同，wire 应该理解为一个信号，信号是有方向性的，wire 从 A 点输出，输入到 B 点和 C 点。wire 一般只有一个 source，即从某一点输出，但可以有多个 sinks，即输入到多个点。A 点通常会被称为一个驱动（driver），把某个值驱动到 wire 上。

+ 把驱动的概念引进到 Verilog 中，可以写作：

+ `assign left_side = right_side;`

+ right_side 的值就被驱动到 left_side 中，以上的语法结构名为连续赋值（continous assignment）。

+ 但请注意与软件中的赋值操作做区分，Verilog 中的赋值是使用一条带有方向的导线连接了两个信号，所以 left_side 始终等于 right_side，随 right_side 变化而变化。而软件中的赋值是一种事件，某个时刻 left_side 的值变成了和 right_side 相同的值。

**2**

+ 模块的输入输出端口实际上都是 wire。事实上，大部分 Verilog 代码之间的顺序都不会对结果产生影响

**3**

+ 如果想要片选多个 bit，那么可以通过如下操作实现，该语法在 C 语言中不存在，但类似 Python 中的切片语法。

+ `assign w = vec[1:0]; `

+ 简单地说定义在向量名之前的是向量的位宽，定义在向量名之后的维度可以理解为向量数组的长

**4**

+ 原则上，你可以在任何位置定义你的信号，使用前使用后都可以，正如之前的课程中说的那样，语句的顺序对于 Verilog 来说没有关系。但有些仿真工具需要你在使用信号之前定义信号，So，你就这么来吧

**5**

+ 我们在 assign 语句中增加的逻辑操作符为 ~（逐位取反），由于我们的信号位宽为 1 位，我们也可以使用！（逻辑取反）。二者的区别在于逻辑取反的结果时钟只有一位，而逐位取反结果的位宽和输入信号位宽相同，在每一个位上逐位（bitwise）取反。

**6**

- assign 语句并不是创建 wire ，而是将创建 wire 之间的连接

**7**

- 向量是一组 wire 信号的集合，通过赋予这一组信号的集合一个名称，以便于访问其中的 wire 信号。

**8** 

- 通过添加 `default_nettype none 宏定义会关闭隐式声明功能，那么这样一来，使用未声明的变量就会变成一个 Error 而不再只是 Warning。

**9**

- 连接操作符的基本语法使用 { } 将较小的向量括起来，每个 { } 内的向量使用逗号作为间隔。

- 连接运算符中的向量务必需要标注位宽

**10**

- 值得注意的是 & 和 && 的区别，& 是逐位与，而 && 是逻辑与。
  - 逐位逻辑运算符：对于 N 比特输入向量之间的逻辑比较，会在 N 比特上逐位进行，并产生一个 N 比特长的运算结果。
  - 逻辑运算符：任何类型的输入都会被视作布尔值，零->假，非零->真，将布尔值进行逻辑比较后，输出一个 1 比特的结果。