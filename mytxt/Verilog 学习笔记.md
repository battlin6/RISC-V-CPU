## Verilog 学习笔记

**1**

+ wire 的中文可以翻译为导线，但 Verilog 中的 wire 和现实中的导线不同，wire 应该理解为一个信号，信号是有方向性的，wire 从 A 点输出，输入到 B 点和 C 点。wire 一般只有一个 source，即从某一点输出，但可以有多个 sinks，即输入到多个点。A 点通常会被称为一个驱动（driver），把某个值驱动到 wire 上。

+ 把驱动的概念引进到 Verilog 中，可以写作：

+ `assign left_side = right_side;`

+ right_side 的值就被驱动到 left_side 中，以上的语法结构名为连续赋值（continous assignment）。

+ 但请注意与软件中的赋值操作做区分，Verilog 中的赋值是使用一条带有方向的导线连接了两个信号，所以 left_side 始终等于 right_side，随 right_side 变化而变化。而软件中的赋值是一种事件，某个时刻 left_side 的值变成了和 right_side 相同的值。

**2**

+ 模块的输入输出端口实际上都是 wire。事实上，大部分 Verilog 代码之间的顺序都不会对结果产生影响

**3**

+ 如果想要片选多个 bit，那么可以通过如下操作实现，该语法在 C 语言中不存在，但类似 Python 中的切片语法。

+ `assign w = vec[1:0]; `

+ 简单地说定义在向量名之前的是向量的位宽，定义在向量名之后的维度可以理解为向量数组的长

**4**

+ 原则上，你可以在任何位置定义你的信号，使用前使用后都可以，正如之前的课程中说的那样，语句的顺序对于 Verilog 来说没有关系。但有些仿真工具需要你在使用信号之前定义信号，So，你就这么来吧

**5**

+ 我们在 assign 语句中增加的逻辑操作符为 ~（逐位取反），由于我们的信号位宽为 1 位，我们也可以使用！（逻辑取反）。二者的区别在于逻辑取反的结果时钟只有一位，而逐位取反结果的位宽和输入信号位宽相同，在每一个位上逐位（bitwise）取反。

**6**

- assign 语句并不是创建 wire ，而是将创建 wire 之间的连接

**7**

- 向量是一组 wire 信号的集合，通过赋予这一组信号的集合一个名称，以便于访问其中的 wire 信号。

**8** 

- 通过添加 `default_nettype none 宏定义会关闭隐式声明功能，那么这样一来，使用未声明的变量就会变成一个 Error 而不再只是 Warning。

**9**

- 连接操作符的基本语法使用 { } 将较小的向量括起来，每个 { } 内的向量使用逗号作为间隔。

- 连接运算符中的向量务必需要标注位宽

**10**

- 值得注意的是 & 和 && 的区别，& 是逐位与，而 && 是逻辑与。
  - 逐位逻辑运算符：对于 N 比特输入向量之间的逻辑比较，会在 N 比特上逐位进行，并产生一个 N 比特长的运算结果。
  - 逻辑运算符：任何类型的输入都会被视作布尔值，零->假，非零->真，将布尔值进行逻辑比较后，输出一个 1 比特的结果。

**11**

+ 模块例化的基本语法 ：模块名 实例名（定义连接 port 的信号）

+ 模块信号连接的两种方式：按端口顺序，按端口名称连接端口。

  + 按端口顺序 

    ```mod_a instance1 ( wa, wb, wc ); ```

    wa, wb, wc 分别连接到模块的 第一个端口（in1），第二个端口（in2）以及第三个端口（out）。这里所谓的端口顺序指的是模块端口的定义顺序。这种方式的弊端在于，一旦端口列表发生改变，所有模块实例化中的端口连接都需要改变。

  + 按端口名称

    ```mod_a instance2 ( .out(wc), .in1(wa), .in2(wb) ); ```

    在这种方式中根据端口名称指定外部信号的连接。这样一来就和端口声明的顺序完全没有关系。一旦模块出现改动，只要修改相应的部分即可。实际上，一般都使用这种方式来进行模块实例化.

**12**

+ 请注意循环变量 i，HDLBits 上的 solution 中，i 定义于 for 循环的括号中，这在 Verilog 的语法中是不被允许的，是 SystemVerilog 的语法。笔者在 ISE 中实测了一下，综合会将其作为警告，但在默认情况下，仿真将会视其为错误。Verilog 的语法需要提前定义 integer 变量，即整型

**13**

+ 模块的层级是通过在模块中例化下一级模块产生的。虽然不同的模块写在不同的 .v 文件中，（一般推荐一个 .v 文件中只写一个模块），但只要这些模块在 ISE/Vivado/Quartus 这些开发软件中处于一个 Project。综合器就能在你例化模块时，找到对应的模块和 .v 文件。
+ 模块中可以例化其他模块，但在模块中不允许再定义其他模块。这项语法规则类似于在 C 语言函数中可以调用其他函数，但不能定义其他函数。

**14**

+ 重复操作符语法就可以在这种情况下帮到你，允许你将一个向量重复多次，并将它们连接在一起，语法是：{ 重复次数 { 向量 } }。
+ 重复次数必须是一个常量，而且请特别注意重复操作符有两对 { }.外层的 {} 不能少

**15**

+ 值得注意的是，在实例化模块时，一般一个端口用一行表示，这样更直观一些。至于逗号放在前面还是放在后面，那倒无所谓。但我看过 NVIDIA 的开源代码将逗号放在前面之后，觉得这样挺好的，故也就这么写了。

**16**

+ 注意：要在模块内部进行连接，您可能需要先声明一些连线。 注意命名连线和模块实例时，它们的名字必须是唯一的。

**17**

* 我们知道数字电路是由导线连接的逻辑门组成，因此任何电路都可以表示为module和assign语句的某种组合。但是，有时候这不是描述电路最简便的方法。过程块(比如always块)提供了一种用于替代assign语句描述电路的方法。

  有两种always块是可以综合出电路硬件的：

  + 综合逻辑：always @(\*)

  + 时序逻辑：always @(posedge clk)

    组合always块相当于assign语句，因此组合电路存在两种表达方法。具体使用哪个主要取决于使用哪个更方便。过程块内的代码与外部的assign代码不同。过程块中可以使用更丰富的语句(比如if-then,case)，但不能包含连续赋值*。但也引入了一些非直观的错误。(*过程连续赋值确实可以存在，但与连续赋值有些不同，并且不可综合)

  例如，assign和组合always块描述相同的电路。两者均创造出了相同的组合逻辑电路。只要任何输入(右侧)改变值，两者都将重新计算输出。

  + ```assign out1 = a & b | c ^ d;```

  + ```always @(*) out2 = a & b | c ^ d;```

    对于组合always块，敏感变量列表总是使用(*)。如果把所有的输入都列出来也是可以的，但容易出错的(可能少列出了一个)，并且在硬件综合时会忽略您少列了一个，仍按原电路综合。 但仿真器将会按少列一个来仿真，这导致了仿真与硬件不匹配。

**18**

+ 在Verilog中有以下三种赋值方法：

  + 连续赋值(assign x=y;)：不能在过程块内使用；

  + 过程阻塞性赋值(x=y;)：只能在过程块中使用；

  + 过程费阻塞性复制(x<=y)：只能在过程块内使用。

    在组合always块中，使用阻塞性赋值。在时序always块中，使用非阻塞性赋值。具体为什么对设计硬件用处不大，还需要理解Verilog模拟器如何跟踪事件(译者注：的确是这样，记住组合用阻塞性，时序用非阻塞性就可以了)。不遵循此规则会导致极难发现非确定性错误，并且在仿真和综合出来的硬件之间存在差异。

**19**

+ 时序always块也会像组合always块一样生成一系列的组合电路，但同时在组合逻辑的输出生成了一组触发器(或寄存器)。该输出在下一个时钟上升沿(posedge clk)后可见，而不是之前的立即可见

**20**

+ 组合电路输出必须在所有输入的情况下都有值。这意味着必须需要else子句或着输出默认值。

**21**

+ 请注意，时钟always块生成了与另外两个不同的电路，多了一个触发器，因此输出会有一定的延迟。

**22**
  ```
always @(*) begin
      casez (in[3:0])
      4'bzzz1: out = 0;  // in[3:1]输入什么都可以
      4'bzz1z: out = 1;
      4'bz1zz: out = 2;
      4'b1zzz: out = 3;
      default: out = 0;
    endcase
  end
  ```

**23**

+ if语句必须在过程块内使用

**The End**



